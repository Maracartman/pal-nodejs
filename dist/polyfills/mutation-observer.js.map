{"version":3,"sources":["polyfills/mutation-observer.ts"],"names":[],"mappings":"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","file":"mutation-observer.js","sourcesContent":["/*\n * Based on Shim for MutationObserver interface\n * Author: Graeme Yeates (github.com/megawac)\n * Repository: https://github.com/megawac/MutationObserver.js\n */\n\nexport class Util {\n  static counter = 1;\n  static expando = 'mo_id';\n\n  static clone($target, config) {\n    let recurse = true; // set true so childList we'll always check the first level\n    return (function copy($target) {\n      let elestruct = {\n        /** @type {Node} */\n        node: $target,\n        charData: null,\n        attr: null,\n        kids: null,\n      };\n\n      // Store current character data of target text or comment node if the config requests\n      // those properties to be observed.\n      if (config.charData && ($target.nodeType === 3 || $target.nodeType === 8)) {\n        elestruct.charData = $target.nodeValue;\n      } else {\n        // Add attr only if subtree is specified or top level and avoid if\n        // attributes is a document object (#13).\n        if (config.attr && recurse && $target.nodeType === 1) {\n          /**\n          * clone live attribute list to an object structure {name: val}\n          * @type {Object.<string, string>}\n          */\n          elestruct.attr = Util.reduce($target.attributes, (memo, attr) => {\n            if (!config.afilter || config.afilter[attr.name]) {\n              memo[attr.name] = attr.value;\n            }\n            return memo;\n          }, {});\n        }\n\n        // whether we should iterate the children of $target node\n        if (recurse && ((config.kids || config.charData) || (config.attr && config.descendents))) {\n          /** @type {Array.<!Object>} : Array of custom clone */\n          elestruct.kids = Util.map($target.childNodes, copy);\n        }\n\n        recurse = config.descendents;\n      }\n      return elestruct;\n    })($target);\n  }\n\n  /**\n  * indexOf an element in a collection of custom nodes\n  *\n  * @param {NodeList} set\n  * @param {!Object} $node : A custom cloned nodeg333\n  * @param {number} idx : index to start the loop\n  * @return {number}\n  */\n  static indexOfCustomNode(set, $node, idx) {\n    const JSCompiler_renameProperty = a => a;\n    return this.indexOf(set, $node, idx, JSCompiler_renameProperty('node'));\n  }\n\n  /**\n  * Attempt to uniquely id an element for hashing. We could optimize this for legacy browsers but it hopefully wont be called enough to be a concern\n  *\n  * @param {Node} $ele\n  * @return {(string|number)}\n  */\n  static getElementId($ele) {\n    try {\n      return $ele.id || ($ele[this.expando] = $ele[this.expando] || this.counter++);\n    } catch (e) { // ie <8 will throw if you set an unknown property on a text node\n      try {\n        return $ele.nodeValue; // naive\n      } catch (shitie) { // when text node is removed: https://gist.github.com/megawac/8355978 :(\n        return this.counter++;\n      }\n    }\n  }\n\n  /**\n  * **map** Apply a mapping function to each item of a set\n  * @param {Array|NodeList} set\n  * @param {Function} iterator\n  */\n  static map(set, iterator) {\n    let results = [];\n    for (let index = 0; index < set.length; index++) {\n      results[index] = iterator(set[index], index, set);\n    }\n    return results;\n  }\n\n  /**\n  * **Reduce** builds up a single result from a list of values\n  * @param {Array|NodeList|NamedNodeMap} set\n  * @param {Function} iterator\n  * @param {*} [memo] Initial value of the memo.\n  */\n  static reduce(set, iterator, memo) {\n    for (let index = 0; index < set.length; index++) {\n      memo = iterator(memo, set[index], index, set);\n    }\n    return memo;\n  }\n\n  /**\n  * **indexOf** find index of item in collection.\n  * @param {Array|NodeList} set\n  * @param {Object} item\n  * @param {number} idx\n  * @param {string} [prop] Property on set item to compare to item\n  */\n  static indexOf(set, item, idx, prop?) {\n    for (/*idx = ~~idx*/; idx < set.length; idx++) {// start idx is always given as this is internal\n      if ((prop ? set[idx][prop] : set[idx]) === item) return idx;\n    }\n    return -1;\n  }\n\n  /**\n  * @param {Object} obj\n  * @param {(string|number)} prop\n  * @return {boolean}\n  */\n  static has(obj, prop) {\n    return obj[prop] !== undefined; // will be nicely inlined by gcc\n  }\n}\n\nexport class MutationObserver {\n  private _watched = [];\n  private _listener = null;\n  private _period = 30;\n  private _timeout = null;\n  private _disposed = false;\n  private _notifyListener = null;\n\n  constructor(listener) {\n    this._watched = [];\n    this._listener = listener;\n    this._period = 30;\n    this._notifyListener = () => { this.scheduleMutationCheck(this); };\n  }\n\n  observe($target, config) {\n    let settings = {\n      attr: !!(config.attributes || config.attributeFilter || config.attributeOldValue),\n\n      // some browsers enforce that subtree must be set with childList, attributes or characterData.\n      // We don't care as spec doesn't specify this rule.\n      kids: !!config.childList,\n      descendents: !!config.subtree,\n      charData: !!(config.characterData || config.characterDataOldValue),\n\n      afilter: null\n    };\n\n    MutationNotifier.getInstance().on(\"changed\", this._notifyListener);\n\n    let watched = this._watched;\n\n    // remove already observed target element from pool\n    for (let i = 0; i < watched.length; i++) {\n      if (watched[i].tar === $target) watched.splice(i, 1);\n    }\n\n    if (config.attributeFilter) {\n      /**\n      * converts to a {key: true} dict for faster lookup\n      * @type {Object.<String,Boolean>}\n      */\n      settings.afilter = Util.reduce(config.attributeFilter, (a, b) => {\n        a[b] = true;\n        return a;\n      }, {});\n    }\n\n    watched.push({\n      tar: $target,\n      fn: this.createMutationSearcher($target, settings)\n    });\n  }\n\n  takeRecords() {\n    let mutations = [];\n    let watched = this._watched;\n\n    for (let i = 0; i < watched.length; i++) {\n      watched[i].fn(mutations);\n    }\n\n    return mutations;\n  }\n\n  disconnect() {\n    this._watched = []; // clear the stuff being observed\n    MutationNotifier.getInstance().removeListener(\"changed\", this._notifyListener );\n    this._disposed = true;\n    clearTimeout(this._timeout); // ready for garbage collection\n    this._timeout = null;\n  }\n\n  private createMutationSearcher($target, config) {\n    /** type {Elestuct} */\n    let $oldstate = Util.clone($target, config); // create the cloned datastructure\n\n    /**\n    * consumes array of mutations we can push to\n    *\n    * @param {Array.<MutationRecord>} mutations\n    */\n    return (mutations) => {\n      let olen = mutations.length;\n      let dirty;\n\n      if (config.charData && $target.nodeType === 3 && $target.nodeValue !== $oldstate.charData) {\n        mutations.push(new MutationRecord({\n          type: 'characterData',\n          target: $target,\n          oldValue: $oldstate.charData\n        }));\n      }\n\n      // Alright we check base level changes in attributes... easy\n      if (config.attr && $oldstate.attr) {\n        this.findAttributeMutations(mutations, $target, $oldstate.attr, config.afilter);\n      }\n\n      // check childlist or subtree for mutations\n      if (config.kids || config.descendents) {\n        dirty = this.searchSubtree(mutations, $target, $oldstate, config);\n      }\n\n      // reclone data structure if theres changes\n      if (dirty || mutations.length !== olen) {\n        /** type {Elestuct} */\n        $oldstate = Util.clone($target, config);\n      }\n    };\n  }\n\n  private scheduleMutationCheck(observer) {\n    // Only schedule if there isn't already a timer. \n    if (!observer._timeout) {\n      observer._timeout = setTimeout(() => this.mutationChecker(observer), this._period);\n    }\n  }\n\n  private mutationChecker(observer) {\n    // allow scheduling a new timer. \n    observer._timeout = null; \n    \n    let mutations = observer.takeRecords();\n\n    if (mutations.length) { // fire away\n      // calling the listener with context is not spec but currently consistent with FF and WebKit\n      observer._listener(mutations, observer);\n    }\n  }\n\n  private searchSubtree(mutations, $target, $oldstate, config) {\n    // Track if the tree is dirty and has to be recomputed (#14).\n    let dirty;\n    /*\n    * Helper to identify node rearrangment and stuff...\n    * There is no gaurentee that the same node will be identified for both added and removed nodes\n    * if the positions have been shuffled.\n    * conflicts array will be emptied by end of operation\n    */\n    const _resolveConflicts = (conflicts, node, $kids, $oldkids, numAddedNodes) => {\n      // the distance between the first conflicting node and the last\n      let distance = conflicts.length - 1;\n      // prevents same conflict being resolved twice consider when two nodes switch places.\n      // only one should be given a mutation event (note -~ is used as a math.ceil shorthand)\n      let counter = -~((distance - numAddedNodes) / 2);\n      let $cur;\n      let oldstruct;\n      let conflict;\n      while ((conflict = conflicts.pop())) {\n        $cur = $kids[conflict.i];\n        oldstruct = $oldkids[conflict.j];\n\n        // attempt to determine if there was node rearrangement... won't gaurentee all matches\n        // also handles case where added/removed nodes cause nodes to be identified as conflicts\n        if (config.kids && counter && Math.abs(conflict.i - conflict.j) >= distance) {\n          mutations.push(new MutationRecord({\n            type: 'childList',\n            target: node,\n            addedNodes: [$cur],\n            removedNodes: [$cur],\n            // haha don't rely on this please\n            nextSibling: $cur.nextSibling,\n            previousSibling: $cur.previousSibling\n          }));\n          counter--; // found conflict\n        }\n\n        // Alright we found the resorted nodes now check for other types of mutations\n        if (config.attr && oldstruct.attr) this.findAttributeMutations(mutations, $cur, oldstruct.attr, config.afilter);\n        if (config.charData && $cur.nodeType === 3 && $cur.nodeValue !== oldstruct.charData) {\n          mutations.push(new MutationRecord({\n            type: 'characterData',\n            target: $cur,\n            oldValue: oldstruct.charData\n          }));\n        }\n        // now look @ subtree\n        if (config.descendents) _findMutations($cur, oldstruct);\n      }\n    };\n\n    /**\n    * Main worker. Finds and adds mutations if there are any\n    * @param {Node} node\n    * @param {!Object} old : A cloned data structure using internal clone\n    */\n    const _findMutations = (node, old) => {\n      let $kids = node.childNodes;\n      let $oldkids = old.kids;\n      let klen = $kids.length;\n      // $oldkids will be undefined for text and comment nodes\n      let olen = $oldkids ? $oldkids.length : 0;\n      // if (!olen && !klen) return; // both empty; clearly no changes\n\n      // we delay the intialization of these for marginal performance in the expected case (actually quite signficant on large subtrees when these would be otherwise unused)\n      // map of checked element of ids to prevent registering the same conflict twice\n      let map;\n      // array of potential conflicts (ie nodes that may have been re arranged)\n      let conflicts;\n      let id; // element id from getElementId helper\n      let idx; // index of a moved or inserted element\n\n      let oldstruct;\n      // current and old nodes\n      let $cur;\n      let $old;\n      // track the number of added nodes so we can resolve conflicts more accurately\n      let numAddedNodes = 0;\n\n      // iterate over both old and current child nodes at the same time\n      let i = 0;\n      let j = 0;\n      // while there is still anything left in $kids or $oldkids (same as i < $kids.length || j < $oldkids.length;)\n      while (i < klen || j < olen) {\n        // current and old nodes at the indexs\n        $cur = $kids[i];\n        oldstruct = $oldkids[j];\n        $old = oldstruct && oldstruct.node;\n\n        if ($cur === $old) { // expected case - optimized for this case\n          // check attributes as specified by config\n          if (config.attr && oldstruct.attr) {/* oldstruct.attr instead of textnode check */\n            this.findAttributeMutations(mutations, $cur, oldstruct.attr, config.afilter);\n          }\n          // check character data if node is a comment or textNode and it's being observed\n          if (config.charData && oldstruct.charData !== undefined && $cur.nodeValue !== oldstruct.charData) {\n            mutations.push(new MutationRecord({\n              type: 'characterData',\n              target: $cur\n            }));\n          }\n\n          // resolve conflicts; it will be undefined if there are no conflicts - otherwise an array\n          if (conflicts) _resolveConflicts(conflicts, node, $kids, $oldkids, numAddedNodes);\n\n          // recurse on next level of children. Avoids the recursive call when there are no children left to iterate\n          if (config.descendents && ($cur.childNodes.length || oldstruct.kids && oldstruct.kids.length)) _findMutations($cur, oldstruct);\n\n          i++;\n          j++;\n        } else { // (uncommon case) lookahead until they are the same again or the end of children\n          dirty = true;\n          if (!map) { // delayed initalization (big perf benefit)\n            map = {};\n            conflicts = [];\n          }\n          if ($cur) {\n            // check id is in the location map otherwise do a indexOf search\n            if (!(map[id = Util.getElementId($cur)])) { // to prevent double checking\n              // mark id as found\n              map[id] = true;\n              // custom indexOf using comparitor checking oldkids[i].node === $cur\n              if ((idx = Util.indexOfCustomNode($oldkids, $cur, j)) === -1) {\n                if (config.kids) {\n                  mutations.push(new MutationRecord({\n                    type: 'childList',\n                    target: node,\n                    addedNodes: [$cur], // $cur is a new node\n                    nextSibling: $cur.nextSibling,\n                    previousSibling: $cur.previousSibling\n                  }));\n                  numAddedNodes++;\n                }\n              } else {\n                conflicts.push({ // add conflict\n                  i: i,\n                  j: idx\n                });\n              }\n            }\n            i++;\n          }\n\n          if ($old &&\n            // special case: the changes may have been resolved: i and j appear congurent so we can continue using the expected case\n            $old !== $kids[i]\n          ) {\n            if (!(map[id = Util.getElementId($old)])) {\n              map[id] = true;\n              if ((idx = Util.indexOf($kids, $old, i)) === -1) {\n                if (config.kids) {\n                  mutations.push(new MutationRecord({\n                    type: 'childList',\n                    target: old.node,\n                    removedNodes: [$old],\n                    nextSibling: $oldkids[j + 1], // praise no indexoutofbounds exception\n                    previousSibling: $oldkids[j - 1]\n                  }));\n                  numAddedNodes--;\n                }\n              } else {\n                conflicts.push({\n                  i: idx,\n                  j: j\n                });\n              }\n            }\n            j++;\n          }\n        }// end uncommon case\n      }// end loop\n\n      // resolve any remaining conflicts\n      if (conflicts) _resolveConflicts(conflicts, node, $kids, $oldkids, numAddedNodes);\n    };\n    _findMutations($target, $oldstate);\n    return dirty;\n  }\n\n  private findAttributeMutations(mutations, $target, $oldstate, filter) {\n    let checked = {};\n    let attributes = $target.attributes;\n    let attr;\n    let name;\n    let i = attributes.length;\n    while (i--) {\n      attr = attributes[i];\n      name = attr.name;\n      if (!filter || Util.has(filter, name)) {\n        if (attr.value !== $oldstate[name]) {\n          // The pushing is redundant but gzips very nicely\n          mutations.push(new MutationRecord({\n            type: 'attributes',\n            target: $target,\n            attributeName: name,\n            oldValue: $oldstate[name],\n            attributeNamespace: attr.namespaceURI // in ie<8 it incorrectly will return undefined\n          }));\n        }\n        checked[name] = true;\n      }\n    }\n    for (name in $oldstate) {\n      if (!(checked[name])) {\n        mutations.push(new MutationRecord({\n          target: $target,\n          type: 'attributes',\n          attributeName: name,\n          oldValue: $oldstate[name]\n        }));\n      }\n    }\n  }\n}\n\nexport class MutationRecord {\n  constructor(data) {\n    let settings = { // technically these should be on proto so hasOwnProperty will return false for non explicitly props\n      type: null,\n      target: null,\n      addedNodes: [],\n      removedNodes: [],\n      previousSibling: null,\n      nextSibling: null,\n      attributeName: null,\n      attributeNamespace: null,\n      oldValue: null\n    };\n    for (let prop in data) {\n      if (Util.has(settings, prop) && data[prop] !== undefined) settings[prop] = data[prop];\n    }\n    return settings;\n  }\n}\n\nimport { EventEmitter } from 'events';\n\nexport class MutationNotifier extends EventEmitter {\n  private static _instance: MutationNotifier = null;\n\n  static getInstance() {\n    if (!MutationNotifier._instance) {\n      MutationNotifier._instance = new MutationNotifier();\n    }\n    return MutationNotifier._instance;\n  }\n\n  constructor() {\n    super();\n    this.setMaxListeners(100);\n  }\n\n  destruct() {\n    this.removeAllListeners(\"changed\");\n  }\n\n  notifyChanged(node: Node) {\n    this.emit(\"changed\", node);\n  }\n}"],"sourceRoot":"../../../src/"}